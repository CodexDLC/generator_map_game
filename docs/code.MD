План по внедрению системы логирования и отладки
1. Регламент Логирования (Logs)
Цель: Создать единую, информативную систему логов, чтобы в любой момент было понятно, что происходит внутри программы, где возникла ошибка и сколько времени заняла та или иная операция.

Инструмент: Стандартный модуль logging в Python. Он мощный и не требует установки новых библиотек.

План внедрения:

Конфигурация:

Мы создадим централизованную функцию для настройки логгера.

Уровни логирования: Договоримся об использовании стандартных уровней:

INFO: Общий ход выполнения ("Запуск генерации региона", "Проект сохранен").

DEBUG: Детальная техническая информация для отладки ("Массив высот после ноды 'Noise': min=-12.3, max=150.7").

WARNING: Не критичная проблема, с которой программа справилась ("Пресет не содержит параметра 'octaves', используется значение по умолчанию: 5").

ERROR: Серьезная ошибка в конкретной операции, которая не привела к падению всего приложения ("Не удалось сохранить превью: отказано в доступе к файлу").

CRITICAL: Фатальная ошибка, после которой приложение не может продолжать работу.

Формат логов: Каждая запись будет содержать: [ВРЕМЯ] - [УРОВЕНЬ] - [ИМЯ_МОДУЛЯ] - [СООБЩЕНИЕ]. Это позволит легко фильтровать и анализировать логи.

Вывод: Логи будут одновременно выводиться в консоль (для быстрой обратной связи) и в файл (например, logs/editor.log) для последующего анализа после сбоя.

Правила использования в коде:

В начале каждого .py файла мы будем инициализировать логгер: logger = logging.getLogger(__name__).

Все важные операции (старт/конец генерации, сохранение/загрузка) будут сопровождаться logger.info().

Все блоки try...except будут логировать ошибку через logger.error() или logger.exception(), чтобы автоматически записывать трейсбек.

2. Блоки Мониторинга (Monitoring)
Цель: Добавить в код точки контроля для отслеживания производительности и корректности данных "на лету".

План внедрения:

Мониторинг производительности:

Ключевые и долгие операции (например, работа каждой ноды в графе, генерация целого региона) мы обернем в простой замер времени (start = time.perf_counter(), end = time.perf_counter()).

Результат будем выводить в лог: logger.info(f"Нода 'Noise' выполнена за {end - start:.3f} сек.").

Мониторинг данных (Sanity Checks):

После выполнения ключевых нод, которые меняют данные (например, карту высот), будем вставлять отладочные проверки.

Пример: logger.debug(f"Карта высот: shape={arr.shape}, min={arr.min():.2f}, max={arr.max():.2f}, has_nan={np.isnan(arr).any()}"). Это сразу покажет, если на каком-то этапе данные "сломались" (например, стали плоскими или содержат некорректные значения).